基本ルール
底面積ベース計算: 体積ではなく底面積で積載量を計算
トラック台数: デフォルト3台 + 非デフォルト1台（必要時）
前倒しルール: 1日前のみ可能
段積み対応: 容器の段積み属性を考慮
処理フロー
Step 1: 需要分析とトラック台数決定 (
_analyze_demand_and_decide_trucks
)
受注データから各日の需要を集計
製品の容器情報、段積み可能性を考慮して底面積を計算
トラックの到着日オフセットから積載日を決定
日平均積載量がデフォルトトラック容量を超える場合、非デフォルトトラックを使用
Step 2: 前倒し処理 (
_forward_scheduling
)
最終日から逆順に処理
各日の積載量がトラック容量を超過する場合、前倒し可能製品を前日に移動
トラックごとの積載状況を追跡し、製品が使用できるトラックで判定
既に前倒しされた製品は再度前倒ししない（1日前のみルール）
Step 3: 日次積載計画作成 (
_create_daily_loading_plan
)
製品を優先度順にソートして積載:

優先順位:

前倒しされた製品
トラック制約が1つのみの製品（最優先）
優先積載製品に指定されている製品
トラック制約がある製品
その他
トラック選択優先順位:

優先積載製品に指定されているトラック
同容器が既に積載されているトラック（段積み統合）
空き容量が大きいトラック
段積み処理:

同じ容器が既に積載されている場合、段積みとして統合
追加で必要な底面積のみを消費
分割積載:

トラック容量が不足する場合、容器単位で分割して積載
Step 4: 積み残しの再配置 (
_relocate_remaining_demands
)
積み残しを他のトラック候補の積載日に再配置を試みる
truck_loading_datesを確認し、各トラックの正しい積載日に空きがあれば配置
元の積載日と同じ日はスキップ（既に失敗済み）
Step 5: 積み残しの前倒し (
_forward_remaining_demands
)
最終日から逆順に処理
前倒し可能フラグ（can_advance）がtrueの製品のみ対象
前日のトラックに空きがあれば前倒し配送
前倒しフラグ（is_advanced）を設定
Step 6: 前日特便配送 (
_relocate_to_next_days
)
前倒しできなかった積み残しは前日特便＝非デフォルトトラックを出す
非デフォルトトラックは翌日着くため、前倒しとならない
主要な計算ロジック
底面積計算
python
# 段積み可能な場合
stacked_containers = (num_containers + max_stack - 1) // max_stack
total_floor_area = floor_area_per_container * stacked_containers

# 段積み不可の場合
total_floor_area = floor_area_per_container * num_containers
積載率計算
容器別に集計して段積みを考慮
積載率 = 積載底面積 / トラック底面積 × 100
営業日考慮
calendar_repoを使用して営業日のみで計画
トラックの積載日が非営業日の場合、前の営業日に調整
出力データ
daily_plans: 日別の積載計画（トラック、製品、積載率）
summary: 総トリップ数、警告数、ステータス
warnings: 積み残し警告（前倒し可/不可を表示）
remaining_demands: 最終的な積み残しリスト
このロジックにより、トラック容量を最大限活用しながら、納期を守る最適な運送計画を自動生成しています